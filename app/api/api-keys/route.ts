import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server'; // Assuming @ is configured for root
import { ApiKey } from '@/lib/supabase/types'; // Assuming @ is configured for root
import { v4 as uuidv4 } from 'uuid'; // For generating API keys, or use crypto

// Helper function to generate a secure API key string
// For a more robust solution, consider using crypto.randomBytes
function generateApiKey(): string {
  // Example: mh_xxxxxxx (MakeHub prefix)
  // This is a simple example; a real key should be longer and more random.
  // Using uuidv4 and removing hyphens, then taking a slice for a shorter key.
  // Or, for a more Supabase-like key, you might use a different format.
  const prefix = 'mh_';
  const key = `${prefix}${uuidv4().replace(/-/g, '')}${uuidv4().replace(/-/g, '')}`;
  return key.substring(0, 64); // Adjust length as needed
}

export async function GET(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Error fetching user or no user:', userError);
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { data: rawKeys, error } = await supabase
      .from('api_keys')
      .select('id, api_key_name, created_at, last_used_at, is_active, api_key') // Fetch the full api_key
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching API keys:', error);
      return NextResponse.json({ error: error.message, details: error.details, hint: error.hint }, { status: 500 });
    }

    // Return the raw keys directly; the client will handle mapping to its ApiKey type
    // This ensures the full api_key is sent.
    return NextResponse.json(rawKeys);
  } catch (e: any) {
    console.error('Unexpected error in GET /api/api-keys:', e);
    return NextResponse.json({ error: e.message || 'An unexpected error occurred' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Error fetching user or no user for POST:', userError);
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { api_key_name } = await request.json();

    if (!api_key_name || typeof api_key_name !== 'string' || api_key_name.trim() === '') {
      return NextResponse.json({ error: 'API key name is required and must be a non-empty string.' }, { status: 400 });
    }

    const newApiKeyString = generateApiKey();

    const { data, error } = await supabase
      .from('api_keys')
      .insert([{ 
        user_id: user.id, 
        api_key_name: api_key_name.trim(),
        api_key: newApiKeyString,
        // id is auto-generated by DB, is_active defaults to true, created_at defaults to now()
      }])
      .select('id, api_key_name, created_at, is_active, api_key') // Return the full key once upon creation
      .single();

    if (error) {
      console.error('Error creating API key:', error);
      // Handle potential unique constraint violation for api_key if generation isn't perfectly unique (though very unlikely with UUIDs)
      if (error.code === '23505') { // Unique violation
        return NextResponse.json({ error: 'Failed to generate a unique API key. Please try again.' }, { status: 500 });
      }
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(data, { status: 201 });
  } catch (e: any) {
    console.error('Unexpected error in POST /api/api-keys:', e);
    if (e instanceof SyntaxError) { // JSON parsing error
        return NextResponse.json({ error: 'Invalid JSON payload' }, { status: 400 });
    }
    return NextResponse.json({ error: e.message || 'An unexpected error occurred' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Error fetching user or no user for DELETE:', userError);
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const apiKeyId = request.nextUrl.searchParams.get('id');

    if (!apiKeyId) {
      return NextResponse.json({ error: 'API key ID is required for deletion.' }, { status: 400 });
    }

    // Validate if apiKeyId is a valid UUID (optional but good practice)
    // const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
    // if (!uuidRegex.test(apiKeyId)) {
    //   return NextResponse.json({ error: 'Invalid API key ID format.' }, { status: 400 });
    // }

    const { error, count } = await supabase
      .from('api_keys')
      .delete({ count: 'exact' }) // Ensure we know how many rows were deleted
      .match({ id: apiKeyId, user_id: user.id }); // Crucial: ensure user owns the key

    if (error) {
      console.error('Error deleting API key:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    if (count === 0) {
        return NextResponse.json({ error: 'API key not found or you do not have permission to delete it.' }, { status: 404 });
    }

    return NextResponse.json({ message: 'API key deleted successfully.' }, { status: 200 });
  } catch (e: any) {
    console.error('Unexpected error in DELETE /api/api-keys:', e);
    return NextResponse.json({ error: e.message || 'An unexpected error occurred' }, { status: 500 });
  }
}
